/**
 * @fileOverview server-side http 请求, 产出Promise
 *               自动解析JSON数据，服务器返回的数据结构顶层为{flag, content/message}
 *               附带桩方法
 * @author Max
 */

import http from 'http';
import querystring from 'querystring';
import url from 'url';
import clone from 'lodash.clonedeep';

export const RES_CONTENT_TYPE = {
    DEFAULT: 'json',
    JSON: 'json',
    RAW: 'raw',
    BUFFER: 'buffer'
};

export default class HTTPHelper {
    constructor({hostname, port, stubHostname, stubPort}) {
        this._hostname = hostname;
        this._port = port;
        this._stubHostname = stubHostname;
        this._stubPort = stubPort;
    }
    // http get options required
    // options: {
    //     url: string, default to _host, _port
    //     resContentType?: RES_CONTENT_TYPE
    // }
    get(options) {
        const _options = this._optionsFilter(options);

        return new Promise((resolve, reject) => {
            console.log('new HTTP GET:', _options.url);
            http.get(_options.url, (res) => {
                resHandler(res, resolve, reject, options.resContentType);
            }).on('error', reject);
        });
    }
    getStub(options) {
        const _options = this._optionsStubFilter(options);

        return new Promise((resolve, reject) => {
            console.log('new HTTP STUB GET:', _options.url);
            http.get(_options.url, (res) => {
                resHandler(res, resolve, reject, options.resContentType);
            }).on('error', reject);
        });
    }
    // http post options required
    // other param in options will be added to node http request options
    // options: {
    //     hostname: string,
    //     port: string,
    //     path: string,
    //     resContentType?: RES_CONTENT_TYPE
    // }
    post(options, data) {

        const _data = querystring.stringify(data);
        const _options = this._optionsFilter(options);
        _options.method = 'POST';
        _options.headers = _options.headers || {};
        _options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        _options.headers['Content-Length'] = _data.length;

        return new Promise((resolve, reject) => {
            console.log('new HTTP POST:', _options.hostname + ':' + _options.port + _options.path);
            const req = http.request(_options, function(res) {
                resHandler(res, resolve, reject, _options.resContentType);
            });

            req.on('error', reject);

            req.write(_data);
            req.end();
        });
    }
    postStub(options, data) {
        const _data = querystring.stringify(data);
        const _options = this._optionsStubFilter(options);
        _options.method = 'POST';
        _options.headers = _options.headers || {};
        _options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        _options.headers['Content-Length'] = _data.length;

        return new Promise((resolve, reject) => {
            console.log('new HTTP STUB POST:', _options.hostname + ':' + _options.port + _options.path);
            const req = http.request(_options, function(res) {
                resHandler(res, resolve, reject, _options.resContentType);
            });

            req.on('error', reject);

            req.write(_data);
            req.end();
        });
    }
    _optionsFilter(options) {
        let result = clone(options);
        if(options.url) {
            const urlObj = url.parse(options.url);
            if(urlObj.hostname === null && urlObj.port === null) {
                result.url = `http://${this._hostname}:${this._port}${options.url}`;
            }
        } else {
            if(options.hostname === undefined && options.port === undefined) {
                result.hostname = this._hostname;
                result.port = this._port;
            }
        }

        return result;
    }
    _optionsStubFilter(options) {
        let result = clone(options);
        if(options.url) {
            const urlObj = url.parse(options.url);
            if(urlObj.hostname === null && urlObj.port === null) {
                result.url = `http://${this._stubHostname}:${this._stubPort}/stub${options.url}`;
            }
        } else {
            if(options.hostname === undefined && options.port === undefined) {
                result.hostname = this._stubHostname;
                result.port = this._stubPort;
                result.path = '/stub' + options.path;
            }
        }

        return result;
    }
}

function resHandler(res, resolve, reject, type) {
    res.setEncoding('utf8');
    var body = '';
    res.on('data', function(chunk) {
        body += chunk;
    });
    res.on('end', function() {
        switch(type) {
            case undefined:
                type = RES_CONTENT_TYPE.DEFAULT;
                /* falls through */
            case RES_CONTENT_TYPE.JSON:
                var json;
                try {
                    json = JSON.parse(body);
                } catch(e) {
                    console.log(body);
                    reject(e);
                    return;
                }

                console.log(json);
                if(json.flag) {
                    resolve(json);
                } else {
                    reject(json);
                }
                break;
            case RES_CONTENT_TYPE.RAW:
                    console.log(body);
                    resolve(body);
                break;
            case RES_CONTENT_TYPE.BUFFER:
                    console.log(body);
                    resolve(new Buffer(body));
                break;
            default:
                reject(new Error('resContentType error'));
        }
    });
    res.on('error', reject);
}
